<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-5">
        <div class="row">
            <div class="col-md-6">
                <h2>Maze Generation</h2>
                <form id="maze-form">
                    <div class="mb-3">
                        <label for="algorithm" class="form-label">Select Generation Algorithm</label>
                        <select class="form-select" id="algorithm" name="algorithm">
                            <option value="dfs">Depth-First Search</option>
                            <option value="prim">Prim's Algorithm</option>
                            <option value="kruskal">Kruskal's Algorithm</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="size" class="form-label">Maze Size</label>
                        <input type="number" class="form-control" id="size" name="size" value="100" placeholder="Enter maze size (e.g., 10)">
                    </div>
                    <div class="mb-3">
                        <label for="speed" class="form-label">Generation Speed (ms per step)</label>
                        <input type="number" class="form-control" id="speed" name="speed" value="1" placeholder="Enter speed in milliseconds">
                    </div>
                </form>
            </div>
            <div class="col-md-6">
                <h2>Maze Solving</h2>
                <form id="solve-form">
                    <div class="mb-3">
                        <label for="solve-algorithm" class="form-label">Select Solving Algorithm</label>
                        <select class="form-select" id="solve-algorithm" name="solve-algorithm">
                            <option value="dfs">Depth-First Search</option>
                            <option value="bfs">Breadth-First Search</option>
                            <option value="astar">A* Search</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="solve-speed" class="form-label">Solving Speed (ms per step)</label>
                        <input type="number" class="form-control" id="solve-speed" name="solve-speed" value="1" placeholder="Enter solving speed in milliseconds">
                    </div>
                </form>
            </div>
        </div>
        <div class="text-center mt-4 d-flex justify-content-center gap-2">
            <button id="generate-button" class="btn btn-primary">Generate Maze</button>
            <button id="solve-button" class="btn btn-success" style="display: none;">Solve Maze</button>
            <button id="stop-button" class="btn btn-danger" style="display: none;">Stop</button>
        </div>
        <div class="text-center mt-4">
            <canvas id="maze-canvas" width="500" height="500" style="border:1px solid #000;"></canvas>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let animationTimeouts = [];
        let generatedMaze = null;
        let startPoint = null;
        let endPoint = null;

        document.getElementById('generate-button').addEventListener('click', async (event) => {
            event.preventDefault();

            const algorithm = document.getElementById('algorithm').value;
            const size = document.getElementById('size').value;
            const speed = document.getElementById('speed').value;

            // Clear any previous animations
            stopAnimation();

            try {
                const response = await fetch('/generate-maze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ algorithm, size })
                });

                if (!response.ok) {
                    throw new Error('Failed to generate maze');
                }

                const data = await response.json();
                const { maze, steps, start, end } = data;

                // Store the generated maze, start, and end points
                generatedMaze = maze;
                startPoint = start;
                endPoint = end;

                animateMaze(maze, steps, size, speed, start, end);

                // Show the solve button after generation
                document.getElementById('solve-button').style.display = 'block';
            } catch (error) {
                alert(error.message);
            }
        });

        document.getElementById('stop-button').addEventListener('click', stopAnimation);

        document.getElementById('solve-button').addEventListener('click', async () => {
            if (!generatedMaze || !startPoint || !endPoint) {
                alert('Maze not generated yet!');
                return;
            }

            const solveAlgorithm = document.getElementById('solve-algorithm').value;
            const solveSpeed = document.getElementById('solve-speed').value; // Retrieve solving speed from input field

            try {
                const response = await fetch('/solve-maze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ maze: generatedMaze, start: startPoint, end: endPoint, algorithm: solveAlgorithm })
                });

                if (!response.ok) {
                    throw new Error('Failed to solve maze');
                }

                const data = await response.json();
                const { solutionSteps, optimalPath } = data;
                const solveSpeed = document.getElementById('solve-speed').value;
                animateSolution(solutionSteps, solveSpeed);
            } catch (error) {
                alert(error.message);
            }
        });

        function animateMaze(maze, steps, size, speed, start, end) {
            const canvas = document.getElementById('maze-canvas');
            const ctx = canvas.getContext('2d');
            const cellSize = canvas.width / size;

            // Show the stop button
            document.getElementById('stop-button').style.display = 'block';

            // Draw the initial maze grid
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Remove the light gray path rendering during generation

            // Draw the start and end points
            ctx.fillStyle = 'green';
            ctx.fillRect(start[1] * cellSize, start[0] * cellSize, cellSize, cellSize);
            ctx.fillStyle = 'red';
            ctx.fillRect(end[1] * cellSize, end[0] * cellSize, cellSize, cellSize);

            // Animate the maze generation
            ctx.fillStyle = 'white';
            steps.forEach(([x, y], index) => {
                if (speed === '0') {
                    // If speed is 0ms, draw all steps instantly
                    ctx.fillRect(y * cellSize, x * cellSize, cellSize, cellSize);
                } else {
                    const timeout = setTimeout(() => {
                        ctx.fillRect(y * cellSize, x * cellSize, cellSize, cellSize);
                        if (index === steps.length - 1) {
                            // Redraw the start and end points after the animation completes
                            ctx.fillStyle = 'green';
                            ctx.fillRect(start[1] * cellSize, start[0] * cellSize, cellSize, cellSize);
                            ctx.fillStyle = 'red';
                            ctx.fillRect(end[1] * cellSize, end[0] * cellSize, cellSize, cellSize);

                            // Hide the stop button
                            document.getElementById('stop-button').style.display = 'none';
                        }
                    }, index * speed);
                    animationTimeouts.push(timeout);
                }
            });
        }

        function animateSolution(solutionSteps, solveSpeed) {
            const canvas = document.getElementById('maze-canvas');
            const ctx = canvas.getContext('2d');
            const cellSize = canvas.width / generatedMaze[0].length;

            ctx.fillStyle = 'blue'; // Use blue to indicate the solution path
            solutionSteps.forEach(([x, y], index) => {
                setTimeout(() => {
                    ctx.fillRect(y * cellSize, x * cellSize, cellSize, cellSize);
                }, index * solveSpeed);
            });
        }

        function stopAnimation() {
            // Clear all timeouts
            animationTimeouts.forEach(timeout => clearTimeout(timeout));
            animationTimeouts = [];

            // Hide the stop button
            document.getElementById('stop-button').style.display = 'none';
        }
    </script>
</body>
</html>
